<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>comfortablely numb's Title</title><link>https://pleasedontbreak123.github.io</link><description>Blog description</description><copyright>comfortablely numb's Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://pic.rmb.bdstatic.com/bjh/240707/74bb18409978753f72ea8236f9cde5fe408.jpeg@h_1280</url><title>avatar</title><link>https://pleasedontbreak123.github.io</link></image><lastBuildDate>Sun, 22 Sep 2024 09:23:29 +0000</lastBuildDate><managingEditor>comfortablely numb's Title</managingEditor><ttl>60</ttl><webMaster>comfortablely numb's Title</webMaster><item><title>哈希表 (HashMap)</title><link>https://pleasedontbreak123.github.io/post/ha-xi-biao-%20%28HashMap%29.html</link><description># 哈希表 （HashMap）&#13;
&#13;
以空间换时间，实现o(1)查找的时间复杂度&#13;
通过hash函数确定存储位置，避免了遍历查找。</description><guid isPermaLink="true">https://pleasedontbreak123.github.io/post/ha-xi-biao-%20%28HashMap%29.html</guid><pubDate>Sun, 22 Sep 2024 09:22:58 +0000</pubDate></item><item><title>并查集（Disjoint sets）</title><link>https://pleasedontbreak123.github.io/post/bing-cha-ji-%EF%BC%88Disjoint%20sets%EF%BC%89.html</link><description># 并查集 (Disjoint sets)&#13;
&#13;
&#13;
## 1.三种思路&#13;
### 1.1 listOfSetsDS&#13;
&#13;
基于List &#13;
| connect | isConnect |&#13;
|------|--------|&#13;
| O(n) | O(n) |&#13;
&#13;
### 1.2 QuickFindDs&#13;
基于数组 &#13;
| connect | isConnect |&#13;
|------|--------|&#13;
| O(n) | O(1) |&#13;
&#13;
### 1.3 QuickUnionDs //最常用 最佳方案&#13;
基于数组 &#13;
| connect | isConnect |&#13;
|------|--------|&#13;
| O(n) | O(n) |&#13;
&#13;
&#13;
## 2.实现 QuickUnionDS&#13;
&#13;
#### 优化一 加权并查集&#13;
保证让小树合并到大树上&#13;
&#13;
追踪每个树的大小（在root上用负号树节点数表示）&#13;
**保证了查到根节点的时间复杂度 O(log N)**&#13;
| connect | isConnect |&#13;
|------|--------|&#13;
| O(logn) | O(logn) |&#13;
&#13;
#### 优化二 路径压缩 &#13;
爬树的同时展平树，将节点连接到root上，将树扁平化&#13;
&#13;
Java 实现  from cs61b2024&#13;
&#13;
```public class UnionFind {&#13;
    private final int[] s;&#13;
    // TODO: Instance variables&#13;
&#13;
    /* Creates a UnionFind data structure holding N items. Initially, all&#13;
       items are in disjoint sets. */&#13;
    public UnionFind(int N) {&#13;
        // TODO: YOUR CODE HERE 初始化数组都置-1&#13;
        s = new int[N];&#13;
        for (int i=0;i &lt; s.length;i++){&#13;
            s[i] = -1;&#13;
        }&#13;
    }&#13;
&#13;
    /* Returns the size of the set V belongs to. */&#13;
    public int sizeOf(int v) {&#13;
        // TODO: YOUR CODE HERE&#13;
        int root = find(v);&#13;
        return -s[root];&#13;
&#13;
    }&#13;
&#13;
    /* Returns the parent of V. If V is the root of a tree, returns the&#13;
       negative size of the tree for which V is the root. */&#13;
    public int parent(int v) {&#13;
        // TODO: YOUR CODE HERE&#13;
        if(s[v] &gt; 0){&#13;
            return s[v];&#13;
        }else {&#13;
            return -sizeOf(v);&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    /* Returns true if nodes/vertices V1 and V2 are connected. */&#13;
    public boolean connected(int v1, int v2) {&#13;
        // TODO: YOUR CODE HERE&#13;
        if (find(v1) == find(v2)){&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /* Returns the root of the set V belongs to. Path-compression is employed&#13;
       allowing for fast search-time. If invalid items are passed into this&#13;
       function, throw an IllegalArgumentException. */&#13;
    public int find(int v) {&#13;
        // TODO: YOUR CODE HERE&#13;
        if(v &lt; 0 || v &gt; s.length){&#13;
            throw new IllegalArgumentException('非法的索引');&#13;
        }&#13;
        if(s[v] &lt; 0){&#13;
            return v;&#13;
        }else {&#13;
            s[v] = find(s[v]);//递归实现路径压缩&#13;
            return s[v];&#13;
        }&#13;
    }&#13;
&#13;
    /* Connects two items V1 and V2 together by connecting their respective&#13;
       sets. V1 and V2 can be any element, and a union-by-size heuristic is&#13;
       used. If the sizes of the sets are equal, tie break by connecting V1's&#13;
       root to V2's root. Union-ing an item with itself or items that are&#13;
       already connected should not change the structure. */&#13;
    public void union(int v1, int v2) {&#13;
        // TODO: YOUR CODE HERE&#13;
        int root1 = find(v1);&#13;
        int root2 = find(v2);&#13;
        if (root1 == root2){&#13;
            return;&#13;
        }&#13;
&#13;
        if (s[root1] &gt;= s[root2]){//由于存的是负数 实际上树2的质量大于树1&#13;
&#13;
            s[root2] = s[root2]+s[root1];&#13;
            s[root1] = root2;&#13;
&#13;
        }else {&#13;
            s[root1] = s[root1]+s[root2];&#13;
            s[root2] = root1;&#13;
        }&#13;
    }&#13;
&#13;
} &#13;
```。</description><guid isPermaLink="true">https://pleasedontbreak123.github.io/post/bing-cha-ji-%EF%BC%88Disjoint%20sets%EF%BC%89.html</guid><pubDate>Tue, 03 Sep 2024 12:18:09 +0000</pubDate></item><item><title>the first blog</title><link>https://pleasedontbreak123.github.io/post/the%20first%20blog.html</link><description>test。</description><guid isPermaLink="true">https://pleasedontbreak123.github.io/post/the%20first%20blog.html</guid><pubDate>Mon, 26 Aug 2024 12:42:09 +0000</pubDate></item></channel></rss>